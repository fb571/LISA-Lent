import bilby    
import numpy as np
import matplotlib.pyplot as plt
from scipy import special
from scipy.signal import get_window
import jax
import jax.numpy as jnp
from functools import partial
import bilby.core.sampler.base_sampler as bs
import shutil

csi = 3e8
L = 2.5e9

def omegaL(f):
    return 2*np.pi*f*L/csi

def sacc(f): #given by equation 13
    return (3e-15/(2*np.pi*f*csi))**2 * (1+(0.4e-3/f)**2)*(1+(f/(8e-3))**4)

def soms(f): #given by equation 10
    return (15e-12)**2 * (2*np.pi*f/csi)**2 * (1+(2e-3/f)**4)

def SnX20(f): #given by equation 20
    omegal = omegaL(f)
    return 64*(np.sin(omegal))**2 * (np.sin(2*omegal))**2 * (soms(f)+(3+np.cos(2*omegal))*sacc(f))

def ShX20(f): #given by equation 57
    omegal = omegaL(f)
    return (20/3) * (1+0.6*(omegal)**2) * (SnX20(f))/(((4*omegal)**2)*((np.sin(omegal))**2)*(2*np.sin(2*omegal))**2)

@jax.jit
def Fplus(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.cos(2*psi) - jnp.cos(theta)*jnp.sin(2*phi)*jnp.sin(2*psi))

@jax.jit
def Fcross(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.sin(2*psi) + jnp.cos(theta)*jnp.sin(2*phi)*jnp.cos(2*psi))

_real_rmtree = shutil.rmtree

def _safe_rmtree(path, *args, **kwargs):
    try:
        _real_rmtree(path, *args, **kwargs)
    except PermissionError:
        pass

shutil.rmtree = _safe_rmtree

jax.config.update("jax_enable_x64", False)

# ============================================================
# 1. Time grid
# ============================================================

np.random.seed(123)
  
label = "freq_peak_with_noise"
outdir = "outdir"
bilby.utils.check_directory_exists_and_if_not_mkdir(outdir)

N = 10000
dt = 10
t = np.arange(N) * dt
t_jax = jnp.asarray(t)

# ============================================================
# 2. True signal parameters
# ============================================================

theta = np.pi/3
phi = np.pi/4
psi = 0

true_f0 = 0.00311
ω = 2 * true_f0 * np.pi
true_e = 0.1
m1 = 0.5 * 2e30
m2 = 0.5 * 2e30
r = 1.5e19
true_CI = np.cos(np.pi/4)

G = 6.67e-11
c = 3e8

a0 = (G * (m1 + m2) / ω**2) ** (1/3)
mu = (m1 * m2) / (m1 + m2)
prefactor = ω**2 * a0**2 * (mu * G) / (r * c**4)

true_A = prefactor
true_peri = np.pi

nmax = 10
n_vals = np.arange(1, nmax + 1)
n_vals_jax = jnp.asarray(n_vals)

e_min, e_max, de = 0, 1, 0.001
e_grid = np.arange(e_min, e_max + de/2, de)
Ne = len(e_grid)
e_grid_jax = jnp.asarray(e_grid)

# --- build using SciPy (once) ---
J_table_3d = np.empty((Ne, nmax, 4), dtype=np.float64)

for ie, e in enumerate(e_grid):
    for j, nj in enumerate(n_vals):
        x = nj * e
        J_table_3d[ie, j, 0] = special.jv(nj - 2, x)
        J_table_3d[ie, j, 1] = special.jv(nj - 1, x)
        J_table_3d[ie, j, 2] = special.jv(nj + 1, x)
        J_table_3d[ie, j, 3] = special.jv(nj + 2, x)

# --- convert ONCE to JAX ---
J_table_3d_jax = jnp.asarray(J_table_3d)

@jax.jit
def get_J_slice_interp_jax(e):
    x = (e - e_min) / de
    i0 = jnp.floor(x).astype(jnp.int32)

    i0 = jnp.clip(i0, 0, J_table_3d_jax.shape[0] - 2)
    w = x - i0

    return (1.0 - w) * J_table_3d_jax[i0] + w * J_table_3d_jax[i0 + 1]

# ============================================================
# 3. Allocation-free time-domain signal model
# ============================================================

@jax.jit
def gw_time_domain_jax(t, A, f0, e, J_slice, CI, peri, n_vals):
    omega = 2.0 * jnp.pi * f0
    pref = -A

    Cperi = jnp.cos(peri)
    Speri = jnp.sin(peri)
    C2peri = jnp.cos(2.0*peri)
    S2peri = jnp.sin(2.0*peri)

    Jm2 = J_slice[:, 0]
    Jm1 = J_slice[:, 1]
    Jp1 = J_slice[:, 2]
    Jp2 = J_slice[:, 3]
    
    nAn = n_vals * (Jm2 - Jp2 - 2.0 * e * (Jm1 - Jp1))
    nBn = n_vals * (1.0 - e * e) * (Jp2 - Jm2)
    nCn = n_vals * jnp.sqrt(1.0 - e * e) * (Jp2 + Jm2 - e * (Jp1 + Jm1))

    phase = omega * t[:, None] * n_vals[None, :]

    A_term = (Cperi**2 - Speri**2 * CI**2)
    B_term = (Speri**2 - Cperi**2 * CI**2)
    C_term = S2peri * (1.0 + CI**2)

    hp = (
        (nAn[None, :] * A_term + nBn[None, :] * B_term) * jnp.cos(phase)
        - nCn[None, :] * C_term * jnp.sin(phase)
    )

    hc = (
    2.0 * jnp.sin(phase) * C2peri * CI * nCn
    + (nAn - nBn) * jnp.cos(phase) * S2peri * CI
    )

    return pref * jnp.sum(hp, axis=1)

J_slice = get_J_slice_interp_jax(true_e)

h_true = gw_time_domain_jax(
    t_jax,
    true_A,
    true_f0,
    true_e,
    J_slice,
    true_CI,
    true_peri,
    n_vals_jax
)

response_true = h_true
window = get_window("hann", N)
window_jax = jnp.asarray(window)
W = np.sum(window**2) / N
norm = np.sqrt(W)

h_fft_true = dt * jnp.fft.rfft(response_true * window_jax) / norm
freqs = np.fft.rfftfreq(N, d=dt)

csi = 3e8
L = 2.5e9

def omegaL(f):
    return 2*np.pi*f*L/csi

def sacc(f): #given by equation 13
    return (3e-15/(2*np.pi*f*csi))**2 * (1+(0.4e-3/f)**2)*(1+(f/(8e-3))**4)

def soms(f): #given by equation 10
    return (15e-12)**2 * (2*np.pi*f/csi)**2 * (1+(2e-3/f)**4)

def SnX20(f): #given by equation 20
    omegal = omegaL(f)
    return 64*(np.sin(omegal))**2 * (np.sin(2*omegal))**2 * (soms(f)+(3+np.cos(2*omegal))*sacc(f))

def ShX20(f): #given by equation 57
    omegal = omegaL(f)
    return (20/3) * (1+0.6*(omegal)**2) * (SnX20(f))/(((4*omegal)**2)*((np.sin(omegal))**2)*(2*np.sin(2*omegal))**2)

@jax.jit
def Fplus(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.cos(2*psi) - jnp.cos(theta)*jnp.sin(2*phi)*jnp.sin(2*psi))

@jax.jit
def Fcross(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.sin(2*psi) + jnp.cos(theta)*jnp.sin(2*phi)*jnp.cos(2*psi))

b = np.zeros(len(freqs))
b[1:] = np.sqrt(ShX20(freqs[1:]) * N * dt / 4)

noise_fft = jnp.asarray(np.random.normal(0, b) + 1j * np.random.normal(0, b))
data_fft = h_fft_true + noise_fft

# ============================================================
# 4. Plotting
# ============================================================

plt.figure(figsize=(10, 6))
plt.plot(t_jax, np.array(response_true), label='GW Signal', color='blue')
plt.xlabel('Time (s)')
plt.ylabel('Strain')
plt.title('Time-Domain GW Signal')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(freqs[200:], jnp.abs(data_fft[200:]), label='Data FFT', color='green')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('FFT of GW Signal with Noise')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# ============================================================
# 5. Likelihood (allocation-free)
# ============================================================

@jax.jit
def g(n_vals_jax,e,J_slice):
    Jm2 = J_slice[:, 0]
    Jm1 = J_slice[:, 1]
    Jp1 = J_slice[:, 2]
    Jp2 = J_slice[:, 3]
    
    A_term = (1/n_vals_jax) * (Jm2 - Jp2 - 2.0 * e * (Jm1 - Jp1))
    B_term = (1/n_vals_jax) * (1.0 - e * e) * (Jp2 - Jm2)
    C_term = (1/n_vals_jax) * jnp.sqrt(1.0 - e * e) * (Jp2 + Jm2 - e * (Jp1 + Jm1))

    return n_vals_jax**6/96 * (A_term**2 + B_term**2 + 3*C_term**2 - A_term*B_term)


noise_magnitude = b

freq_mask = (freqs > 0.005) & (freqs < 0.01)
freq_indices = np.where(freq_mask)[0]
freq_indices_jax = jnp.asarray(freq_indices)

noise_slice = jnp.take(noise_magnitude, freq_indices_jax)
noise2 = noise_slice * noise_slice
log_norm = jnp.sum(jnp.log(2 * jnp.pi * noise2))

def log_likelihood_fn(R, f0, e, phi1, phi2, phi3, t, data_fft, dt,
                      window_jax, norm, noise2, freq_indices, n_vals_restr):
    

    omega = 2.0 * jnp.pi * f0
    J_slice_full = get_J_slice_interp_jax(e)
    J_slice_restr = jnp.take(J_slice_full, n_vals_restr - 1, axis=0)
    phase = omega * t[:, None] * n_vals_restr[None, :]
    phi_n = jnp.array([phi1, phi2, phi3])

    harmonics = R*(jnp.sqrt(g(n_vals_restr,e,J_slice_restr))/n_vals_restr)[None,:]*jnp.sin(phase - phi_n[None, :])

    h_td = jnp.sum(harmonics, axis=1)

    h_fft = dt * jnp.fft.rfft(h_td * window_jax) / norm
    diff = jnp.take(data_fft - h_fft, freq_indices)
    return -0.5 * jnp.sum((diff.real**2 + diff.imag**2) / noise2) \
           -0.5 * log_norm

log_likelihood_jit = jax.jit(
    partial(
        log_likelihood_fn,
        t=t_jax,
        data_fft=data_fft,
        dt=dt,
        window_jax=window_jax,
        norm=norm,
        noise2=noise2,
        freq_indices=freq_indices_jax,
        n_vals_restr=jnp.asarray([2,3,4])
    )
)

class FFTGWLikelihood(bilby.Likelihood):
    def __init__(self, t, data_fft, dt):
        super().__init__(parameters=dict(R=None, f0=None, e=None, phi1=None, phi2=None, phi3=None))
        self.t = t
        self.data_fft = data_fft
        self.dt = dt

    def log_likelihood(self):
        R   = jnp.asarray(self.parameters["R"])
        f0  = jnp.asarray(self.parameters["f0"])
        e = jnp.asarray(self.parameters["e"])
        phi1 = jnp.asarray(self.parameters["phi1"])
        phi2 = jnp.asarray(self.parameters["phi2"])
        phi3 = jnp.asarray(self.parameters["phi3"])
        return log_likelihood_jit(R, f0, e, phi1, phi2, phi3)

# ============================================================
# 6. Priors
# ============================================================

from bilby.core.prior import PriorDict, Uniform, Constraint
priors = PriorDict()
priors["R"] = Uniform(0, 2e-21, name="R", latex_label=r"$R$")
priors["f0"] = Uniform(0.003, 0.005, name="f_0", latex_label=r"$f_0\ \mathrm{[Hz]}$")
priors["e"] = Uniform(0, 0.5, name="e", latex_label=r"e")
priors["phi1"] = Uniform(0, 2*np.pi, name="phi1", latex_label=r"\phi_1")
priors["phi2"] = Uniform(0, 2*np.pi, name="phi2", latex_label=r"\phi_2")
priors["phi3"] = Uniform(0, 2*np.pi, name="phi3", latex_label=r"\phi_3")

# ============================================================
# 9. Run bilby
# ============================================================

likelihood = FFTGWLikelihood(t, data_fft, dt)

result = bilby.run_sampler(
    likelihood=likelihood,
    priors=priors,
    sampler="ultranest",

    outdir="outdir",
    label="fft_gw_freq_noise",

    overwrite=False,                 
    use_temporary_directory=False, 

    clean=False,
    sampler_kwargs=dict(
    log_level="warning",
    stepsampler="slice"
),
    nlive=200,
)

param_order = ["R", "f0", "e", "phi1", "phi2", "phi3"]

result.plot_corner(
    parameters=param_order,
    bins=40,
    smooth=1.0,
    quantiles=[0.16, 0.84],
)
plt.show()
result.save_to_file()
