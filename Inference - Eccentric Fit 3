import bilby    
import numpy as np
import matplotlib.pyplot as plt
from scipy import special
from scipy.signal import get_window
import jax
import jax.numpy as jnp
import jax.scipy.special as jsp
from functools import partial
import bilby.core.sampler.base_sampler as bs
import shutil

_real_rmtree = shutil.rmtree

def _safe_rmtree(path, *args, **kwargs):
    try:
        _real_rmtree(path, *args, **kwargs)
    except PermissionError:
        pass

shutil.rmtree = _safe_rmtree

jax.config.update("jax_enable_x64", True)

# ============================================================
# 1. Time grid
# ============================================================

np.random.seed(123)

label = "freq_peak_with_noise"
outdir = "outdir"
bilby.utils.check_directory_exists_and_if_not_mkdir(outdir)

N = 10000
dt = 10
t = jnp.arange(N) * dt

# ============================================================
# 2. True signal parameters
# ============================================================

theta = np.pi/3
phi = np.pi/4
psi = 0

true_f0 = 0.00311
ω = 2 * true_f0 * np.pi
true_e = 0.1
m1 = 0.5 * 2e30
m2 = 0.5 * 2e30
r = 1.5e19
true_CI = np.cos(np.pi/4)

G = 6.67e-11
c = 3e8

a0 = (G * (m1 + m2) / ω**2) ** (1/3)
mu = (m1 * m2) / (m1 + m2)
prefactor = ω**2 * a0**2 * (mu * G) / (r * c**4)

true_A = prefactor
true_phi = np.pi/2

nmax = 10
n_vals = jnp.arange(1, nmax + 1)

e_min, e_max, de = 0, 1, 0.001
e_grid = np.arange(e_min, e_max + de/2, de)
Ne = len(e_grid)
e_grid_jax = jnp.asarray(e_grid)

J_table_3d = np.empty((Ne, nmax, 4), dtype=np.float64)

for ie, e in enumerate(e_grid):
    for j, nj in enumerate(n_vals):
        x = nj * e
        J_table_3d[ie, j, 0] = special.jv(nj - 2, x)
        J_table_3d[ie, j, 1] = special.jv(nj - 1, x)
        J_table_3d[ie, j, 2] = special.jv(nj + 1, x)
        J_table_3d[ie, j, 3] = special.jv(nj + 2, x)

# --- convert ONCE to JAX ---
J_table_3d_jax = jnp.asarray(J_table_3d)

@jax.jit
def get_J_slice_interp_jax(e):
    x = (e - e_min) / de
    i0 = jnp.floor(x).astype(jnp.int32)

    i0 = jnp.clip(i0, 0, J_table_3d_jax.shape[0] - 2)
    w = x - i0

    return (1.0 - w) * J_table_3d_jax[i0] + w * J_table_3d_jax[i0 + 1]

# ============================================================
# 3. Allocation-free time-domain signal model
# ============================================================

@jax.jit
def gw_time_domain_jax(t, A, f0, e, J_slice, CI, phi, n_vals):
    omega = 2.0 * jnp.pi * f0
    pref = -A

    Cphi = jnp.cos(phi)
    Sphi = jnp.sin(phi)
    C2phi = jnp.cos(2.0*phi)
    S2phi = jnp.sin(2.0*phi)

    Jm2 = J_slice[:, 0]
    Jm1 = J_slice[:, 1]
    Jp1 = J_slice[:, 2]
    Jp2 = J_slice[:, 3]
    
    nAn = n_vals * (Jm2 - Jp2 - 2.0 * e * (Jm1 - Jp1))
    nBn = n_vals * (1.0 - e * e) * (Jp2 - Jm2)
    nCn = n_vals * jnp.sqrt(1.0 - e * e) * (Jp2 + Jm2 - e * (Jp1 + Jm1))

    phase = omega * t[:, None] * n_vals[None, :]

    A_term = (Cphi**2 - Sphi**2 * CI**2)
    B_term = (Sphi**2 - Cphi**2 * CI**2)
    C_term = S2phi * (1.0 + CI**2)

    hp = (
        (nAn[None, :] * A_term + nBn[None, :] * B_term) * jnp.cos(phase)
        - nCn[None, :] * C_term * jnp.sin(phase)
    )
    
    hplus = pref * jnp.sum(hp, axis=1)
    
    return hplus

J_slice = get_J_slice_interp_jax(true_e)

h_true = gw_time_domain_jax(
    t,
    true_A,
    true_f0,
    true_e,
    J_slice,
    true_CI,
    true_phi,
    n_vals
)

# ============================================================
# 4. Window + FFT (NO time-domain noise)
# ============================================================

@jax.jit
def Fplus(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.cos(2*psi) - jnp.cos(theta)*jnp.sin(2*phi)*jnp.sin(2*psi))

@jax.jit
def Fcross(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.sin(2*psi) + jnp.cos(theta)*jnp.sin(2*phi)*jnp.cos(2*psi))

response_true = h_true[:, 0]*Fplus(theta, phi, psi) + h_true[:, 1]*Fcross(theta, phi, psi)
window = get_window("hann", N)
window_jax = jnp.asarray(window)
W = np.sum(window**2) / N
norm = np.sqrt(W)

h_fft_true = dt * jnp.fft.rfft(response_true * window_jax) / norm
freqs = np.fft.rfftfreq(N, d=dt)

print(true_A)

# ============================================================
# 5. Add noise directly in frequency domain
# ============================================================

csi = 3e8
L = 2.5e9

@jax.jit
def omegaL(f):
    return 2*jnp.pi*f*L/csi

@jax.jit
def Sacc(f):
    return (3e-15/(2*jnp.pi*f*csi))**2 * (1+(0.4e-3/f)**2)*(1+(f/(8e-3))**4)

@jax.jit
def Soms(f):
    return (15e-12)**2 * (2*jnp.pi*f/csi)**2 * (1+(2e-3/f)**4)

@jax.jit
def SnX20(f):
    omegal = omegaL(f)
    return 64*(jnp.sin(omegal))**2 * (jnp.sin(2*omegal))**2 * (Soms(f)+(3+jnp.cos(2*omegal))*Sacc(f))

@jax.jit
def ShX20(f):
    omegal = omegaL(f)
    return (20/3) * (1+0.6*(omegal)**2) * (SnX20(f))/(((4*omegal)**2)*((jnp.sin(omegal))**2)*(2*jnp.sin(2*omegal))**2)

@jax.jit
def Fplus(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.cos(2*psi) - jnp.cos(theta)*jnp.sin(2*phi)*jnp.sin(2*psi))

@jax.jit
def Fcross(theta,phi,psi):
    return jnp.sqrt(3)/2 * (0.5*(1+jnp.cos(theta)**2)*jnp.cos(2*phi)*jnp.sin(2*psi) + jnp.cos(theta)*jnp.sin(2*phi)*jnp.cos(2*psi))

b = jnp.zeros(len(freqs))
b = b.at[1:].set(jnp.sqrt(ShX20(freqs[1:]) * N * dt / 4))

noise_fft = jnp.asarray(np.random.normal(0, b) + 1j * np.random.normal(0, b))
data_fft = h_fft_true + noise_fft

# ============================================================
# 4. Plotting
# ============================================================

plt.figure(figsize=(10, 6))
plt.plot(t, np.array(response_true), label='GW Signal', color='blue')
plt.xlabel('Time (s)')
plt.ylabel('Strain')
plt.title('Time-Domain GW Signal')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(freqs[200:], jnp.abs(data_fft[200:]), label='Data FFT', color='green')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('FFT of GW Signal with Noise')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# ============================================================
# 5. Likelihood (allocation-free)
# ============================================================

noise_magnitude = b

freq_mask = (freqs > 0.005) & (freqs < 0.01)
freq_indices = jnp.where(freq_mask)[0]

noise_slice = jnp.take(noise_magnitude, freq_indices)
noise2 = noise_slice * noise_slice
log_norm = jnp.sum(jnp.log(2 * jnp.pi * noise2))

def log_likelihood_fn(A, f0, e, phi, CI, t, data_fft, dt, nvals,
                      window_jax, norm, noise2, freq_indices):
    J = get_J_slice_interp_jax(e)
    h_td = gw_time_domain_jax(t, A, f0, e, J, CI, phi, nvals)
    response = h_td[:, 0]*Fplus(theta, phi, psi) + h_td[:, 1]*Fcross(theta, phi, psi)
    h_fft = dt * jnp.fft.rfft(response * window_jax) / norm
    diff = jnp.take(data_fft - h_fft, freq_indices)
    return -0.5 * jnp.sum((diff.real**2 + diff.imag**2) / noise2) \
           -0.5 * log_norm

# JIT the pure function
log_likelihood_jit = jax.jit(
    partial(
        log_likelihood_fn,
        t=t,
        data_fft=data_fft,
        dt=dt,
        nvals = n_vals,
        window_jax=window_jax,
        norm=norm,
        noise2=noise2,
        freq_indices=freq_indices
    )
)

class FFTGWLikelihood(bilby.Likelihood):
    def __init__(self, t, data_fft, dt):
        super().__init__(parameters=dict(A=None, f0=None, e=None, phi=None, CI=None))
        self.t = t
        self.data_fft = data_fft
        self.dt = dt

    def log_likelihood(self):
        A   = jnp.asarray(self.parameters["A"])
        f0  = jnp.asarray(self.parameters["f0"])
        e   = jnp.asarray(self.parameters["e"])
        phi = jnp.asarray(self.parameters["phi"])
        CI = jnp.asarray(self.parameters["CI"])
        return log_likelihood_jit(A, f0, e, phi, CI)

# ============================================================
# 8. Priors
# ============================================================

priors = dict(
    A   = bilby.core.prior.Uniform(0, 4e-21, "A"),
    f0  = bilby.core.prior.Uniform(0.003, 0.005, "f0"),
    e   = bilby.core.prior.Uniform(0, 0.2, "e"),
    phi = bilby.core.prior.Uniform(0, np.pi, "phi"),
    CI = bilby.core.prior.Uniform(-1, 1, "CI")
)

# ============================================================
# 9. Run bilby
# ============================================================

likelihood = FFTGWLikelihood(t, data_fft, dt)

result = bilby.run_sampler(
    likelihood=likelihood,
    priors=priors,
    sampler="ultranest",
    
    outdir="outdir",
    label="fft_gw_freq_noise",
                    
    use_temporary_directory=False, 
    clean=False,
    
    # SPEED-OPTIMIZED ULTRANEST SETTINGS:
    nlive=150,  # Moderate number of live points
    
    sampler_kwargs=dict(
        min_num_live_points=150,  # Minimum live points
        cluster_num_live_points=20,  # Small clustering threshold
        
        # Stopping criteria - very loose for speed:
        dlogz=0.1,  # Loose evidence tolerance
        dKL=1.0,  # Loose KL divergence
        frac_remain=0.5,  # Stop when 50% of evidence remains
        
        # Limits:
        max_ncalls=30000,  # Maximum function evaluations
        max_iters=10000,  # Maximum iterations
        
        # Speed optimizations:
        update_interval_volume_fraction=0.5,  # Less frequent updates
        show_status=True,  # Show progress
    ),
)

# Define new plot ranges
param_order = ["A", "f0", "e", "phi", "CI"]

plot_ranges = [
    (0, 3e-21),              # A
    (0.003, 0.0032),         # f0
    (0.05, 0.15),            # e
    (0, np.pi),              # phi
    (-1, 1),                 # CI
]

truths = [
    true_A,
    true_f0,
    true_e,
    true_phi,
    true_CI,
]

# Generate new corner plot with updated ranges
result.plot_corner(
    parameters=param_order,
    truths=truths,
    truth_color="red",
    bins=40,
    smooth=1.0,
    quantiles=[0.16, 0.84],
    range=plot_ranges,  # Note: it's 'range', not 'ranges'
)
plt.show()
